name: "ðŸš¨ Security Incident Automation"

on:
  schedule:
    - cron: "11 */6 * * *"
  workflow_dispatch:
  workflow_run:
    workflows:
      - "CodeQL Advanced (auto-detect)"
      - "ðŸ”’ Deep Security Scan (Optimized)"
      - "Secret Scanning"
      - "ðŸ—ï¸ IaC Security (Optimized)"
      - "ðŸ³ Container Security (Optimized)"
      - "ðŸ§ª Continuous Fuzzing"
      - "ðŸ“¦ Supply Chain Provenance"
    types: [completed]

permissions:
  contents: read
jobs:
  incident-tracker:
    name: "Update Security Incident Tracker"
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: read
      issues: write
    steps:
      - name: Create or Update Incident Issue
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const INCIDENT_TITLE = 'Security Incident Tracker (Automated)';
            const INCIDENT_LABELS = ['security-incident', 'automated', 'security'];

            async function ensureLabel(name, color, description) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (err) {
                if (err.status === 404) {
                  await github.rest.issues.createLabel({ owner, repo, name, color, description });
                } else {
                  throw err;
                }
              }
            }

            await ensureLabel('security-incident', 'B60205', 'Automated security incident tracker');
            await ensureLabel('automated', '1D76DB', 'Created and updated by automation');
            await ensureLabel('security', 'D93F0B', 'Security related issue');

            const codeAlerts = await github.paginate(
              github.rest.codeScanning.listAlertsForRepo,
              { owner, repo, state: 'open', per_page: 100 }
            );

            function classifyCodeSeverity(alert) {
              const numeric = Number(alert?.rule?.security_severity_level);
              if (Number.isFinite(numeric)) {
                if (numeric >= 9) return 'critical';
                if (numeric >= 7) return 'high';
                if (numeric >= 4) return 'medium';
                return 'low';
              }
              const fallback = String(alert?.rule?.severity || '').toLowerCase();
              if (fallback === 'critical') return 'critical';
              if (fallback === 'high' || fallback === 'error') return 'high';
              if (fallback === 'medium' || fallback === 'warning') return 'medium';
              return 'low';
            }

            const codeHighCritical = codeAlerts.filter((a) => {
              const sev = classifyCodeSeverity(a);
              return sev === 'critical' || sev === 'high';
            });

            let secretAlerts = [];
            let secretApiError = null;
            try {
              secretAlerts = await github.paginate(
                github.rest.secretScanning.listAlertsForRepo,
                { owner, repo, state: 'open', per_page: 100 }
              );
            } catch (err) {
              secretApiError = err.message;
            }

            let securityAndAnalysis = null;
            try {
              const repoInfo = await github.rest.repos.get({ owner, repo });
              securityAndAnalysis = repoInfo?.data?.security_and_analysis || null;
            } catch (_) {
              securityAndAnalysis = null;
            }

            const status = {
              dependencyGraph: securityAndAnalysis?.dependency_graph?.status || 'unknown',
              dependabotAlerts: securityAndAnalysis?.dependabot_alerts?.status || 'unknown',
              secretScanning: securityAndAnalysis?.secret_scanning?.status || 'unknown',
              pushProtection: securityAndAnalysis?.secret_scanning_push_protection?.status || 'unknown',
            };

            const settingsFindings = [];
            const settingsObservations = [];
            function collectSettingFinding(label, value) {
              if (value === 'enabled') return;
              if (value === 'unknown' || value === 'not_available') {
                settingsObservations.push(`${label} is \`${value}\` (insufficient permissions or unavailable).`);
                return;
              }
              settingsFindings.push(`${label} is \`${value}\`.`);
            }

            collectSettingFinding('Dependency Graph', status.dependencyGraph);
            collectSettingFinding('Dependabot Alerts', status.dependabotAlerts);
            collectSettingFinding('Secret Scanning', status.secretScanning);
            collectSettingFinding('Secret Scanning Push Protection', status.pushProtection);

            const shouldOpenIncident =
              codeHighCritical.length > 0 ||
              secretAlerts.length > 0 ||
              settingsFindings.length > 0;

            const trackerIssues = await github.paginate(
              github.rest.issues.listForRepo,
              {
                owner,
                repo,
                state: 'open',
                labels: 'security-incident,automated',
                per_page: 100,
              }
            );
            const existing = trackerIssues.find((issue) => issue.title === INCIDENT_TITLE);

            function renderCodeRows(items) {
              if (!items.length) return '- None';
              return items.slice(0, 20).map((a) => {
                const sev = classifyCodeSeverity(a);
                const rule = a?.rule?.id || 'unknown-rule';
                const tool = a?.tool?.name || 'unknown-tool';
                const url = a?.html_url || `https://github.com/${owner}/${repo}/security/code-scanning`;
                return `- [${tool}] ${rule} (\`${sev}\`) - ${url}`;
              }).join('\n');
            }

            function renderSecretRows(items) {
              if (!items.length) return '- None';
              return items.slice(0, 20).map((a) => {
                const type = a?.secret_type_display_name || a?.secret_type || 'unknown-secret-type';
                const location = a?.locations_url || `https://github.com/${owner}/${repo}/security/secret-scanning`;
                return `- ${type} - ${location}`;
              }).join('\n');
            }

            const body = [
              '# Automated Security Incident Tracker',
              '',
              `- Updated: ${new Date().toISOString()}`,
              `- Code scanning open alerts: **${codeAlerts.length}**`,
              `- Code scanning high/critical: **${codeHighCritical.length}**`,
              `- Secret scanning open alerts: **${secretAlerts.length}**`,
              '',
              '## High/Critical Code Scanning Alerts',
              renderCodeRows(codeHighCritical),
              '',
              '## Open Secret Scanning Alerts',
              renderSecretRows(secretAlerts),
              '',
              '## Repository Security Settings',
              `- Dependency Graph: \`${status.dependencyGraph}\``,
              `- Dependabot Alerts: \`${status.dependabotAlerts}\``,
              `- Secret Scanning: \`${status.secretScanning}\``,
              `- Push Protection: \`${status.pushProtection}\``,
              '',
              settingsFindings.length ? '### Settings Findings\n' + settingsFindings.map((x) => `- ${x}`).join('\n') : '### Settings Findings\n- None',
              '',
              settingsObservations.length ? '### Settings Observations (Non-Blocking)\n' + settingsObservations.map((x) => `- ${x}`).join('\n') : '### Settings Observations (Non-Blocking)\n- None',
              '',
              secretApiError ? `### Secret Scanning API\n- Could not query secret scanning alerts: \`${secretApiError}\`` : '### Secret Scanning API\n- Query successful',
              '',
              '## Security Links',
              `- Code Scanning: https://github.com/${owner}/${repo}/security/code-scanning`,
              `- Secret Scanning: https://github.com/${owner}/${repo}/security/secret-scanning`,
              `- Dependabot: https://github.com/${owner}/${repo}/security/dependabot`,
            ].join('\n');

            if (shouldOpenIncident) {
              if (existing) {
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: existing.number,
                  body,
                  labels: INCIDENT_LABELS,
                });
                core.notice(`Updated existing incident tracker issue #${existing.number}`);
              } else {
                const created = await github.rest.issues.create({
                  owner,
                  repo,
                  title: INCIDENT_TITLE,
                  body,
                  labels: INCIDENT_LABELS,
                });
                core.notice(`Created incident tracker issue #${created.data.number}`);
              }
            } else if (existing) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: existing.number,
                body: `Resolved automatically at ${new Date().toISOString()} - no open high/critical code scanning alerts, no open secret scanning alerts, and no settings findings.`,
              });
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: existing.number,
                state: 'closed',
              });
              core.notice(`Closed resolved incident tracker issue #${existing.number}`);
            } else {
              core.notice('No security incident to track right now.');
            }
